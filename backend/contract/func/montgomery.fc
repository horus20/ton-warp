const int BASE = 0x10000000000000000;
const int Q = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
const int R = 944936681149208446651664254269745548490766851729442924617792859073125903783;  ;; rSquare
const int M = 14042775128853446655;

tuple getQ() inline {
  return long(Q);
}

tuple getR() inline {
  return long(R);
}

_ madd0(int a, int b, int c) {
  var tmp = a * b;
  var lo = tmp % BASE;
  var hi = tmp / BASE;
  var carry = (lo + c) / BASE;

  return (hi + carry);
}

_ madd1(int a, int b, int c) {
  var tmp = a * b;
  var lo = tmp % BASE;
  var hi = tmp / BASE;
  tmp = (lo + c);
  var carry =  tmp / BASE;
  lo = tmp % BASE;

  return [(hi + carry), lo];
}

;; hi, lo = a*b + c + d
_ madd2(int a, int b, int c, int d) {
  var tmp = a * b;
  var lo = tmp % BASE;
  var hi = tmp / BASE;
  tmp = c + d;
  var carry = tmp / BASE;
  c = tmp % BASE;
  hi = hi + carry;
  tmp = lo + c;
  carry = tmp / BASE;
  lo = tmp % BASE;

  return [(hi + carry), lo];
}

_ madd3(int a, int b, int c, int d, int e) {
  var tmp = a * b;
  var lo = tmp % BASE;
  var hi = tmp / BASE;
  tmp = c + d;
  var carry = tmp / BASE;
  c = tmp % BASE;
  hi = hi + carry;
  tmp = lo + c;
  carry = tmp / BASE;
  lo = tmp % BASE;

  return [(hi + e + carry), lo];
}

tuple checkOverflow(int z0, int z1, int z2, int z3) inline {
  var z = unsafe_tuple([z0, z1, z2, z3]);
  var zI = longToInt(z);
  if (zI > Q) {
		z = long(zI - Q);
  }

  return z;
}

tuple mulGeneric(tuple x, tuple y) inline {
  int t0 = 0;
  int t1 = 0;
  int t2 = 0;
  int t3 = 0;
  int c0 = 0;
  int c1 = 0;
  int c2 = 0;
  int z0 = 0;
  int z1 = 0;
  int z2 = 0;
  int z3 = 0;

  ;; round 0
  var v = 0;
  if (x.length() > 0) {
    v = x.getByIndex(0);
  }
  var tmp = v * y.getByIndex(0);
  c1 = tmp / BASE;
  c0 = tmp % BASE;
  var m = c0 * M % BASE;
  c2 = madd0(m, getQ().getByIndex(0), c0);
  [c1, c0] = madd1(v, y.getByIndex(1), c1);
  [c2, t0] = madd2(m, getQ().getByIndex(1), c2, c0);
  [c1, c0] = madd1(v, y.getByIndex(2), c1);
  [c2, t1] = madd2(m, getQ().getByIndex(2), c2, c0);
  [c1, c0] = madd1(v, y.getByIndex(3), c1);
  [t3, t2] = madd3(m, getQ().getByIndex(3), c0, c2, c1);

  ;; round 1
  v = 0;
  if (x.length() > 1) {
    v = x.getByIndex(1);
  }
  [c1, c0] = madd1(v, y.getByIndex(0), t0);
  m = c0 * M % BASE;
  c2 = madd0(m, getQ().getByIndex(0), c0);
  [c1, c0] = madd2(v, y.getByIndex(1), c1, t1);
  [c2, t0] = madd2(m, getQ().getByIndex(1), c2, c0);
  [c1, c0] = madd2(v, y.getByIndex(2), c1, t2);
	[c2, t1] = madd2(m, getQ().getByIndex(2), c2, c0);
	[c1, c0] = madd2(v, y.getByIndex(3), c1, t3);
	[t3, t2] = madd3(m, getQ().getByIndex(3), c0, c2, c1);

  ;; round 2
  v = 0;
  if (x.length() > 2) {
    v = x.getByIndex(2);
  }
  [c1, c0] = madd1(v, y.getByIndex(0), t0);
  m = c0 * M % BASE;
  c2 = madd0(m, getQ().getByIndex(0), c0);
  [c1, c0] = madd2(v, y.getByIndex(1), c1, t1);
  [c2, t0] = madd2(m, getQ().getByIndex(1), c2, c0);
  [c1, c0] = madd2(v, y.getByIndex(2), c1, t2);
	[c2, t1] = madd2(m, getQ().getByIndex(2), c2, c0);
	[c1, c0] = madd2(v, y.getByIndex(3), c1, t3);
	[t3, t2] = madd3(m, getQ().getByIndex(3), c0, c2, c1);

  ;; round 3
  v = 0;
  if (x.length() > 3) {
    v = x.getByIndex(3);
  }
  [c1, c0] = madd1(v, y.getByIndex(0), t0);
  m = c0 * M % BASE;
  c2 = madd0(m, getQ().getByIndex(0), c0);
  [c1, c0] = madd2(v, y.getByIndex(1), c1, t1);
  [c2, z0] = madd2(m, getQ().getByIndex(1), c2, c0);
  [c1, c0] = madd2(v, y.getByIndex(2), c1, t2);
  [c2, z1] = madd2(m, getQ().getByIndex(2), c2, c0);
	[c1, c0] = madd2(v, y.getByIndex(3), c1, t3);
	[z3, z2] = madd3(m, getQ().getByIndex(3), c0, c2, c1);

  ;;return unsafe_tuple([z, t0, t1, t2, t3, c0, c1, c2, m, v]);
  return checkOverflow(z0, z1, z2, z3);
}

tuple addGeneric(tuple x, tuple y) inline {
  int z0 = 0;
  int z1 = 0;
  int z2 = 0;
  int z3 = 0;
  int carry = 0;

  int tmp = x.getByIndex(0) + y.getByIndex(0);
  carry = tmp / BASE;
  z0 = tmp % BASE;

  tmp = x.getByIndex(1) + y.getByIndex(1) + carry;
  carry = tmp / BASE;
  z1 = tmp % BASE;

  tmp = x.getByIndex(2) + y.getByIndex(2) + carry;
  carry = tmp / BASE;
  z2 = tmp % BASE;

  tmp = x.getByIndex(3) + y.getByIndex(3) + carry;
  carry = tmp / BASE;
  z3 = tmp % BASE;

  return checkOverflow(z0, z1, z2, z3);
}
